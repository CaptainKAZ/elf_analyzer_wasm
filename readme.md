# ELF Variable Analyzer (Wasm + DWARF)

[![Build and Deploy](https://github.com/CaptainKAZ/elf_analyzer_wasm/actions/workflows/deploy.yml/badge.svg)](https://github.com/CaptainKAZ/elf_analyzer_wasm/actions/workflows/deploy.yml) 

A web-based tool to analyze ELF (Executable and Linkable Format) files, leveraging DWARF debug information to recursively parse variables (including globals and statics) down to their primitive components. It displays the variable's fully qualified name, base type, memory address, size, and declaration location (file/line). Built with Rust and compiled to WebAssembly (Wasm) to run directly in the browser.


* **ELF Parsing**: Reads ELF file structure.
* **DWARF-based Analysis**: Traverses DWARF debug information (`.debug_info`, `.debug_line`, etc.) to find variable definitions.
* **Recursive Type Resolution**: Breaks down complex types (structs, arrays, unions) into their base components.
* **Static & Global Variable Discovery**: Identifies both globally visible symbols and file/function-scope static variables (requires DWARF).
* **Address Calculation**: Determines the memory address of each primitive component.
* **File & Line Information**: Extracts the declaration location (file and line number) for variables from DWARF.
* **C++ Name Demangling**: Attempts to demangle C++ symbols for better readability.
* **WebAssembly Powered**: Runs entirely in the browser, no server-side processing needed after loading.
* **Frontend**: Simple HTML interface with filtering and pagination for displaying results.
* **CI/CD**: Automatic build and deployment to GitHub Pages via GitHub Actions.

## Key Technologies Used

* **Rust**: Core logic implementation.
* **WebAssembly (Wasm)**: Target compilation format for browser execution.
* **`wasm-pack`**: Tool for building and packaging Rust Wasm projects.
* **`object` crate**: For parsing the basic ELF file structure.
* **`gimli` crate**: For parsing DWARF debug information.
* **`cpp_demangle` crate**: For demangling C++ names.
* **`wasm-logger` / `log`**: For logging within the Wasm module (viewable in browser console).
* **HTML / CSS / JavaScript**: Frontend interface.
* **GitHub Actions**: For continuous integration and deployment.
* **GitHub Pages**: For hosting the live application.

## How It Works

1.  The user uploads an ELF file (compiled with debug information, e.g., `-g`).
2.  The JavaScript frontend reads the file into an `ArrayBuffer`.
3.  The `ArrayBuffer` is passed to the WebAssembly module function `analyze_elf_recursively`.
4.  The Rust code uses the `object` crate to parse the ELF structure and the `gimli` crate to parse DWARF sections.
5.  It iterates through DWARF Compilation Units (CUs) and Debugging Information Entries (DIEs) to find `DW_TAG_variable` entries.
6.  For each variable, it attempts to determine its name (demangling C++ names), location (address), and type information.
7.  It recursively walks the type DIEs (`DW_TAG_structure_type`, `DW_TAG_array_type`, etc.) to break down complex types into `BaseVariableInfo` structs containing the flattened name, base type, address, size, and declaration location.
8.  The resulting list of `BaseVariableInfo` is serialized and returned to JavaScript.
9.  The JavaScript frontend displays the results in a filterable, paginated table.

## Building and Running Locally

**Prerequisites:**

* Rust toolchain (install via [rustup.rs](https://rustup.rs/))
* `wasm-pack` (install via `cargo install wasm-pack`)
* A local web server (e.g., Python's `http.server`, `npx http-server`)

**Steps:**

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/https://github.com/CaptainKAZ/elf_analyzer_wasm.git
    cd elf_analyzer_wasm
    ```
2.  **Build the Wasm package:**
    ```bash
    wasm-pack build --target web --release
    ```
    This compiles the Rust code to Wasm and generates the necessary JavaScript bindings in the `pkg/` directory.
3.  **Start a local web server:**
    From the project root directory:
    ```bash
    # Using Python 3
    python3 -m http.server 8000

    # Or using Node.js (if http-server is installed: npm i -g http-server)
    # http-server . -p 8000
    ```
4.  **Open in browser:**
    Navigate to `http://localhost:8000` (or the appropriate URL for your server, making sure it serves the `index.html` and the `pkg` directory correctly).

## Deployment

This project is automatically built and deployed to GitHub Pages on every push to the `main` branch using the workflow defined in `.github/workflows/deploy.yml`.

## Limitations

* **DWARF Complexity**: DWARF is complex. This parser handles common structures but may not correctly interpret all DWARF features, especially those generated by highly optimizing compilers or for complex C++ features (templates, advanced inheritance, etc.).
* **Location Evaluation**: Currently only evaluates simple `DW_AT_location` expressions (specifically `DW_OP_addr`). Variables with locations defined by complex expressions or location lists might not have their addresses resolved.
* **Performance**: Parsing large ELF files with extensive DWARF information can be computationally intensive and may take time in the browser.
* **Demangling**: While `cpp_demangle` is used, perfect demangling for all C++ constructs and compiler variations isn't guaranteed.

## Contributing

Contributions are welcome! Please feel free to open an issue or submit a pull request.

## License

This project is licensed under the [MIT License](LICENSE-MIT.txt)